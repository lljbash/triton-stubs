from collections.abc import Callable, Mapping, Sequence
from typing import Any, Protocol

import torch
from _typeshed import Incomplete

class Benchmarker(Protocol):
    def __call__(
        self,
        kernel_call: Callable[..., Any],
        *,
        quantiles: list[float],
        **kwargs: Incomplete,
    ) -> Sequence[float]: ...

class _Utils:
    load_binary: Incomplete
    get_device_properties: Callable[[torch.types.Device], Mapping[str, Incomplete]]
    cuOccupancyMaxActiveClusters: Incomplete
    set_printf_fifo_size: Incomplete
    fill_tma_descriptor: Incomplete

class DriverBase:
    def __init__(self) -> None: ...
    def is_active(self) -> bool: ...
    def map_python_to_cpp_type(self, ty: str) -> str: ...
    def get_current_target(self) -> Incomplete: ...
    def get_active_torch_device(self) -> torch.device: ...
    def get_benchmarker(self) -> Benchmarker: ...

    # GPUDriver
    @staticmethod
    def get_device_capability(device: torch.types.Device = None) -> tuple[int, int]: ...
    @staticmethod
    def get_current_stream(device: int) -> int: ...
    @staticmethod
    def get_current_device() -> int: ...
    @staticmethod
    def set_current_device(device: torch.types.Device) -> int: ...

    # CudaDriver/HIPDriver
    utils: _Utils
    launcher_cls: type
    def get_device_interface(self) -> Any: ...
    def get_empty_cache_for_benchmark(self) -> torch.Tensor: ...
    def clear_cache(self, cache: torch.Tensor) -> None: ...

    # Fallback
    def __getattr__(self, name: str) -> Incomplete: ...

class DriverConfig:
    @property
    def default(self) -> DriverBase: ...
    @property
    def active(self) -> DriverBase: ...
    def set_active(self, driver: DriverBase) -> None: ...
    def reset_active(self) -> None: ...

driver: DriverConfig
